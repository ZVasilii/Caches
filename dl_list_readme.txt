Это инструкция по использованию двусвязного списка.

Внутренние файлы списка: dl_list.c, dl_cells.c

Заголовочный файл: dl_list.h, pages.h



Список состоит из ячеек: 
Объявление ячейки: struct cell <name>
Внутреннее строение (работа напрямую не предусмотрена):
struct cell {
    struct cell* prev;
    struct cell* next;
    long long int data;
    struct page_t* page_ptr;
};

Доступные функции:

Создание одной ячейки:
struct cell* make_cell()
Создает ячейку, возвращает указатель на нее. Имя по умолчанию 0, указатель на страницу отсутствует.
Не забудьте почистить память после использования. 
struct cell* make_cell_n(long long int name)
Создает ячейку с заданным именем
struct cell* make_cell_p(long long int name, struct page_t* page_ptr)
Создает ячейку с заданным указателем.
struct cell* make_cell_np(long long int name, struct page_t* page_ptr)
Создает ячейку с заданным именем и указателем.

Уничтожение ячейки: 
void destroy_cell(struct cell* c) 
Уничтожает одну ячейку по введенному указателю, очищая память.
Затягивает "дыры", которые могли остаться на ее месте.
void destroy_all_cells(struct cell* c) 
Уничтожает указанную ячейку и все, которые с ней связаны. 
Предусмотрена работа на зацикленных списках.

Перемещение ячейки: 
struct cell* place_cell_before(struct cell* c, struct cell* place)
struct cell* place_cell_after(struct cell* c, struct cell* place)
Перемещает ячеку *с на позицию до или после *place. Затягивает "дыры", которые могли остаться на старом месте.
Вставление между двумя подряд идущими ячейками предусмотрено.

Получение имени ячейки: 
long long int cell_name(struct cell* c)
Возвращает имя ячейки по указателю.

Переход к предыдущей/следующей ячейке:
struct cell* next_cell(struct cell* c)
struct cell* prev_cell(struct cell* c)
Получает указатель на текущую ячейку, возвращает указатель на следующую/предыдущую.

Работа с указателем ячейки:
struct cell* set_page(struct cell* c, struct page_t* page_ptr)
Записывает в ячейку значение введенного указателя, старый при наличии безвозвратно затирается.
Возращает указатель на ячейку.
struct page_t* cell_page(struct cell* c)
Возвращает записанный в ячейку указатель. При отстутствии возращает NULL.

Поиск ячейки:
struct cell* find_cell(struct list_t* l, long long int name)
Ищет ячейку с заданным именем, возвращает указатель на нее. l - указатель на список.
При наличии нескольких ячеек с одинаковым именем возвращает любую.

Нахождение длины списка:
unsigned long long list_len(struct cell* c)
Возвращает длину списка по любой его ячейке. Предусмотрена работа с зацикленными списками.


Сам список представлен открытой для внешнего использования структурой
struct list_t {
    struct cell* head;
    unsigned long long length;
    struct cell* end;
    struct cell* last_found;
};

Функции для работы со списком:

Создание списка без ячеек
struct list_t* make_list()
Возвращает указатель на список. Все указатели NULL, длина 0.

Удаление списка (вместе с ячейками)
void destroy_list(struct list_t* l)

Поиск элемента списка по названию.
struct cell* find_list_elem(struct list_t* l, long long int name)
Найденный элемент возвращается функцией и записывается в last_found.

Вставка элемента в начало списка
struct cell* insert_to_head(struct list_t* l, struct cell* c)

Перестановка элемента 
struct cell* replace_lf_to_head(struct list_t* cur, struct list_t* next)
Переставляет last found элемент cur в начало next. 
Cur и next могут быть как разными, так и одним и тем же списком.

Удаляет последний элемент списка.
void delete_last_elem(struct list_t* l)

Тестирование работоспособности списка:
void list_test()
Сделано при помощи реализации сортировки вставками.

